<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>#f6978d — Project</title>
    <style>
      @font-face{
        font-family: 'Darker Grotesque';
        src: url('Assets/DarkerGrotesque-VariableFont_wght.ttf') format('truetype');
        font-weight: 100 900;
        font-style: normal;
        font-display: swap;
      }

      :root{--tile: url('Assets/Circles tile.png')}
      html,body{height:100%;margin:0}
      body{
        background-image: var(--tile);
        background-repeat: repeat;
        background-position: 0 0;
        background-size: auto;
        overflow:hidden;
      }
      /* bottom links */
      .bottom-link{
        position:fixed;
        bottom:24px;
        left:24px;
        color:#f6978d;
        text-decoration:none;
        font-family:'Darker Grotesque', Arial, sans-serif;
        font-size:24px;
        background:transparent;
        padding:8px 8px;
        z-index:10003;
      }
      .bottom-link.right{ left:auto; right:16px }
      .bottom-link:focus-visible{ outline:none; box-shadow:0 0 0 4px rgba(118,151,141,0.14) }
      .content{
        position:fixed;inset:0;display:grid;place-items:center;color:#111;font-family:Arial,Helvetica,sans-serif;
        pointer-events:none
      }
      
      /* Hover label */
      #hover-label{
        position: fixed;
        pointer-events: none;
        font-family: 'Darker Grotesque', Arial, sans-serif;
        font-size: 16px;
        color: #f6978d;
        z-index: 10001;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.2s ease;
        transform: translateX(-50%);
      }
      #hover-label.visible{
        opacity: 1;
      }
    </style>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="custom-cursor" aria-hidden="true"></div>
    <div id="hover-label"></div>

    <svg id="cutleryOverlay" xmlns="http://www.w3.org/2000/svg" style="position:fixed;inset:0;width:100%;height:100%;pointer-events:auto;z-index:10002;">
      <defs>
        <pattern id="cutleryPat" patternUnits="userSpaceOnUse" width="100" height="100">
          <image id="cutleryImage" href="Assets/Cutlery tiles.svg" x="0" y="0" width="100" height="100" preserveAspectRatio="xMinYMin slice" />
        </pattern>

        <mask id="cutleryMask">
          <rect x="0" y="0" width="100%" height="100%" fill="black" />
          <circle id="cutleryMaskCircle" cx="-9999" cy="-9999" r="30" fill="white" />
        </mask>
      </defs>
      <rect id="clickableArea" width="100%" height="100%" fill="url(#cutleryPat)" mask="url(#cutleryMask)" style="pointer-events:auto"></rect>
    </svg>

    <a class="bottom-link right" href="coming-soon.html">More collections</a>

    <script>
      (function(){
        const body = document.body;
        const cursor = document.getElementById('custom-cursor');
        const hoverLabel = document.getElementById('hover-label');

        body.style.margin = '0';
        body.style.backgroundRepeat = 'repeat';
        body.style.backgroundPosition = '0 0';

        let cursorSize = 360;
        const minSize = 20, maxSize = 480;
        Object.assign(cursor.style, {
          position: 'fixed',
          width: cursorSize + 'px',
          height: cursorSize + 'px',
          borderRadius: '50%',
          pointerEvents: 'none',
          transform: 'translate(-50%, -50%)',
          zIndex: 9999,
          background: 'rgba(246,151,141,0.92)',
          mixBlendMode: 'normal',
          transition: 'width 0.12s ease, height 0.12s ease, transform 0.06s linear'
        });

        document.documentElement.style.setProperty('cursor', 'none', 'important');
        document.body.style.setProperty('cursor', 'none', 'important');

        let pointer = { x: null, y: null, inside: false };
        let currentHoveredUtensil = null;

        window.addEventListener('pointermove', (e)=>{
          pointer.x = e.clientX;
          pointer.y = e.clientY;
          pointer.inside = true;
          cursor.style.left = e.clientX + 'px';
          cursor.style.top = e.clientY + 'px';
          updateCutleryMask(e.clientX, e.clientY, cursorSize);
          
          // Check hover state
          checkHover(e.clientX, e.clientY);
        }, {passive:true});
        
        window.addEventListener('pointerleave', ()=>{ 
          pointer.x = null; 
          pointer.y = null; 
          pointer.inside = false; 
          updateCutleryMask(-9999, -9999, cursorSize);
          hideLabel();
        });

        let posX = 0, posY = 0;

        const circlesTile = new Image();
        let tileW = 100, tileH = 100;
        circlesTile.onload = function(){
          tileW = circlesTile.naturalWidth || tileW;
          tileH = circlesTile.naturalHeight || tileH;
          console.log(`Tile dimensions loaded: ${tileW}x${tileH}`);
          const cutleryPat = document.getElementById('cutleryPat');
          const cutleryImage = document.getElementById('cutleryImage');
          if(cutleryPat){
            cutleryPat.setAttribute('width', tileW);
            cutleryPat.setAttribute('height', tileH);
          }
          if(cutleryImage){
            cutleryImage.setAttribute('width', tileW);
            cutleryImage.setAttribute('height', tileH);
          }
        };
        circlesTile.src = 'Assets/Circles tile.png';

        const cutleryPat = document.getElementById('cutleryPat');
        const cutleryMaskCircle = document.getElementById('cutleryMaskCircle');

        // Map of utensil positions with labels
        const utensilMap = [
          { name: 'S1', label: 'Spoon', file: 'Assets/Models/S1_Model.obj', x: 36.86, y: 47.99, radius: 20 },
          { name: 'S2', label: 'Dessert Spoon', file: 'Assets/Models/S2_Model.obj', x: 72.19, y: 15.95, radius: 20 },
          { name: 'S3', label: 'Soup Spoon', file: 'Assets/Models/S3_Model.obj', x: 60.07, y: 72.87, radius: 20 },
          { name: 'F1', label: 'Fork', file: 'Assets/Models/F1_Model.obj', x: 93.12, y: 57.09, radius: 22 },
          { name: 'F2', label: 'Fish Fork', file: 'Assets/Models/F2_Model.obj', x: 19.34, y: 76.19, radius: 22 },
          { name: 'F3', label: 'Cheese Fork', file: 'Assets/Models/F3_Model.obj', x: 88.94, y: 91.06, radius: 22 },
          { name: 'K1', label: 'Knife', file: 'Assets/Models/K1_Model.obj', x: 92.52, y: 45.86, radius: 20 },
          { name: 'K2', label: 'Butter Knife', file: 'Assets/Models/K2_Model.obj', x: 29.95, y: 28.83, radius: 20 },
          { name: 'K3', label: 'Cheese Knife', file: 'Assets/Models/K3_Model.obj', x: 74.07, y: 36.40, radius: 20 }
        ];

        function checkHover(clientX, clientY) {
          const rect = document.getElementById('clickableArea').getBoundingClientRect();
          const clickX = clientX - rect.left;
          const clickY = clientY - rect.top;

          const tileX = ((clickX - posX) % tileW + tileW) % tileW;
          const tileY = ((clickY - posY) % tileH + tileH) % tileH;

          const tileXPercent = (tileX / tileW) * 100;
          const tileYPercent = (tileY / tileH) * 100;

          let foundUtensil = null;

          for (const utensil of utensilMap) {
            const dx = tileXPercent - utensil.x;
            const dy = tileYPercent - utensil.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= utensil.radius) {
              foundUtensil = utensil;
              break;
            }
          }

          if (foundUtensil && foundUtensil !== currentHoveredUtensil) {
            currentHoveredUtensil = foundUtensil;
            showLabel(foundUtensil.label, clientX, clientY);
          } else if (!foundUtensil && currentHoveredUtensil) {
            currentHoveredUtensil = null;
            hideLabel();
          } else if (foundUtensil && foundUtensil === currentHoveredUtensil) {
            // Update label position
            updateLabelPosition(clientX, clientY);
          }
        }

        function showLabel(text, x, y) {
          hoverLabel.textContent = text;
          hoverLabel.classList.add('visible');
          updateLabelPosition(x, y);
        }

        function updateLabelPosition(x, y) {
          // Position below the cursor (at the bottom-most point)
          const labelY = y + (cursorSize / 2) + 16; // 16px gap below cursor
          hoverLabel.style.left = x + 'px';
          hoverLabel.style.top = labelY + 'px';
        }

        function hideLabel() {
          hoverLabel.classList.remove('visible');
        }

        const clickableArea = document.getElementById('clickableArea');
        if (clickableArea) {
          clickableArea.addEventListener('click', (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const tileX = ((clickX - posX) % tileW + tileW) % tileW;
            const tileY = ((clickY - posY) % tileH + tileH) % tileH;

            const tileXPercent = (tileX / tileW) * 100;
            const tileYPercent = (tileY / tileH) * 100;

            console.log('=== CLICK DEBUG ===');
            console.log(`Screen position: (${clickX.toFixed(1)}, ${clickY.toFixed(1)})`);
            console.log(`Tile position: (${tileX.toFixed(1)}, ${tileY.toFixed(1)})`);
            console.log(`Tile percentage: (${tileXPercent.toFixed(2)}%, ${tileYPercent.toFixed(2)}%)`);
            console.log(`Pan offset: (${posX.toFixed(1)}, ${posY.toFixed(1)})`);
            console.log(`Tile size: ${tileW}x${tileH}`);

            for (const utensil of utensilMap) {
              const dx = tileXPercent - utensil.x;
              const dy = tileYPercent - utensil.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              console.log(`${utensil.name} at (${utensil.x.toFixed(2)}%, ${utensil.y.toFixed(2)}%): distance = ${distance.toFixed(2)} (threshold: ${utensil.radius})`);

              if (distance <= utensil.radius) {
                console.log(`✓ HIT! Downloading ${utensil.name}`);
                
                (async () => {
                  let statusEl = document.getElementById('downloadStatus');
                  if (!statusEl) {
                    statusEl = document.createElement('div');
                    statusEl.id = 'downloadStatus';
                    Object.assign(statusEl.style, {
                      position: 'fixed', 
                      right: '16px', 
                      top: '16px', 
                      padding: '8px 12px', 
                      background: 'rgba(0,0,0,0.85)', 
                      color:'#fff', 
                      fontSize:'14px', 
                      borderRadius:'6px', 
                      zIndex: 100000,
                      fontFamily: 'Arial, sans-serif'
                    });
                    document.body.appendChild(statusEl);
                  }

                  try {
                    statusEl.textContent = `Fetching ${utensil.label}...`;
                    console.log(`Fetching: ${utensil.file}`);
                    
                    const res = await fetch(utensil.file, { cache: 'no-store' });
                    statusEl.textContent = `HTTP ${res.status} ${res.statusText}`;
                    
                    if (!res.ok) {
                      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                    
                    const blob = await res.blob();
                    statusEl.textContent = `Preparing download...`;
                    
                    const url = URL.createObjectURL(blob);
                    const filename = utensil.file.split('/').pop();
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    statusEl.textContent = `✓ Downloaded: ${utensil.label}`;
                    console.log(`✓ Download complete: ${filename}`);
                    
                    setTimeout(() => { 
                      URL.revokeObjectURL(url); 
                      statusEl.textContent = ''; 
                    }, 3000);
                  } catch (err) {
                    console.error('Download failed:', err);
                    statusEl.textContent = `✗ Failed: ${err.message}`;
                    statusEl.style.background = 'rgba(200,0,0,0.85)';
                    
                    setTimeout(() => {
                      window.open(utensil.file, '_blank');
                    }, 1000);
                  }
                })();
                return;
              }
            }

            console.log('No utensil clicked');
          });
        }

        function syncCutleryPat(){
          if(cutleryPat) cutleryPat.setAttribute('patternTransform', `translate(${posX} ${posY})`);
        }

        function updateCutleryMask(x, y, size){
          if(!cutleryMaskCircle) return;
          cutleryMaskCircle.setAttribute('cx', String(x));
          cutleryMaskCircle.setAttribute('cy', String(y));
          cutleryMaskCircle.setAttribute('r', String(size/2));
        }

        const edgeThreshold = 48;
        const maxSpeed = 7.2;

        function rafLoop(){
          if(pointer.inside && pointer.x !== null){
            const w = window.innerWidth, h = window.innerHeight;
            let vx = 0, vy = 0;

            if(pointer.x <= edgeThreshold) {
              vx = maxSpeed * (1 - pointer.x / edgeThreshold);
            } else if(pointer.x >= w - edgeThreshold){
              vx = -maxSpeed * (1 - (w - pointer.x) / edgeThreshold);
            }

            if(pointer.y <= edgeThreshold){
              vy = maxSpeed * (1 - pointer.y / edgeThreshold);
            } else if(pointer.y >= h - edgeThreshold){
              vy = -maxSpeed * (1 - (h - pointer.y) / edgeThreshold);
            }

            if(vx !== 0 || vy !== 0){
              posX += vx;
              posY += vy;
              body.style.backgroundPosition = `${posX}px ${posY}px`;
              syncCutleryPat();
            }
          }

          requestAnimationFrame(rafLoop);
        }
        requestAnimationFrame(rafLoop);

        window.addEventListener('wheel', (e)=>{
          const delta = -e.deltaY;
          if(Math.abs(delta) < 0.5) return;
          e.preventDefault();
          const change = delta * 0.4;
          const oldSize = cursorSize;
          cursorSize = Math.max(minSize, Math.min(maxSize, Math.round(cursorSize + change)));
          cursor.style.width = cursorSize + 'px';
          cursor.style.height = cursorSize + 'px';
          updateCutleryMask(pointer.x || window.innerWidth/2, pointer.y || window.innerHeight/2, cursorSize);
          
          // Update label position if visible
          if (currentHoveredUtensil && pointer.x) {
            updateLabelPosition(pointer.x, pointer.y);
          }
        }, {passive:false});
      })();
    </script>
  </body>
</html>