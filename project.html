<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>#f6978d â€” Project</title>
    <style>
      @font-face{
        font-family: 'Darker Grotesque';
        src: url('Assets/DarkerGrotesque-VariableFont_wght.ttf') format('truetype');
        font-weight: 100 900;
        font-style: normal;
        font-display: swap;
      }

      :root{--tile: url('Assets/Circles tile.png')}
      html,body{height:100%;margin:0}
      body{
        background-image: var(--tile);
        background-repeat: repeat;
        background-position: 0 0;
        background-size: auto;
        overflow:hidden;
      }
      /* bottom links */
      .bottom-link{
        position:fixed;
        bottom:24px;
        left:24px;
        color:#f6978d;
        text-decoration:none;
        font-family:'Darker Grotesque', Arial, sans-serif;
        font-size:24px;
        background:transparent;
        padding:8px 8px;
        z-index:10003; /* ensure bottom links sit above the SVG overlay */
      }
      .bottom-link.right{ left:auto; right:16px }
      .bottom-link:focus-visible{ outline:none; box-shadow:0 0 0 4px rgba(118,151,141,0.14) }
      .content{
        position:fixed;inset:0;display:grid;place-items:center;color:#111;font-family:Arial,Helvetica,sans-serif;
        pointer-events:none
      }
 
    </style>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <!-- Empty page with tiled background and a custom circular cursor -->
    <div id="custom-cursor" aria-hidden="true"></div>

      <!-- Cutlery SVG overlay (tiled). Masked so only the area inside the cursor circle is visible.
           Positioned above the cursor so the tiled SVG appears on top of the cursor color. -->
  <svg id="cutleryOverlay" ... style="position:fixed;inset:0;width:100%;height:100%;pointer-events:auto;z-index:10002;">
        <defs>
          <pattern id="cutleryPat" patternUnits="userSpaceOnUse" width="100" height="100">
            <image id="cutleryImage" href="Assets/Cutlery tiles.svg" x="0" y="0" width="100" height="100" preserveAspectRatio="xMinYMin slice" />
          </pattern>

          <!-- mask: white circle reveals overlay only inside the cursor -->
          <mask id="cutleryMask">
            <rect x="0" y="0" width="100%" height="100%" fill="black" />
            <circle id="cutleryMaskCircle" cx="-9999" cy="-9999" r="30" fill="white" />
          </mask>
        </defs>
          <rect id="clickableArea" width="100%" height="100%" fill="url(#cutleryPat)" mask="url(#cutleryMask)" style="pointer-events:auto"></rect>
      </svg>


  <a class="bottom-link right" href="coming-soon.html">More collections</a>



    <script>
      // Static tiled background, edge-triggered panning, and resizable circular cursor
      (function(){
        const body = document.body;
        const cursor = document.getElementById('custom-cursor');

        // remove default margins/padding and ensure seamless repeat
        body.style.margin = '0';
        body.style.backgroundRepeat = 'repeat';
        body.style.backgroundPosition = '0 0';

        // style the cursor element
        let cursorSize = 120; // initial size in px
        const minSize = 20, maxSize = 480;
        Object.assign(cursor.style, {
          position: 'fixed',
          width: cursorSize + 'px',
          height: cursorSize + 'px',
          borderRadius: '50%',
          pointerEvents: 'none',
          transform: 'translate(-50%, -50%)',
          zIndex: 9999,
          background: 'rgba(246,151,141,0.92)',
          mixBlendMode: 'normal',
          transition: 'width 0.12s ease, height 0.12s ease, transform 0.06s linear'
                 
        });
  // hide the native cursor with important priority on both html and body
  document.documentElement.style.setProperty('cursor', 'none', 'important');
  document.body.style.setProperty('cursor', 'none', 'important');

        // pointer tracking
        let pointer = { x: null, y: null, inside: false };
        window.addEventListener('pointermove', (e)=>{
          pointer.x = e.clientX;
          pointer.y = e.clientY;
          pointer.inside = true;
          cursor.style.left = e.clientX + 'px';
          cursor.style.top = e.clientY + 'px';
          // update SVG mask to reveal overlay inside cursor
          updateCutleryMask(e.clientX, e.clientY, cursorSize);
        }, {passive:true});
        window.addEventListener('pointerleave', ()=>{ pointer.x = null; pointer.y = null; pointer.inside = false; updateCutleryMask(-9999, -9999, cursorSize); });

        // Background pan state (pixels)
        let posX = 0, posY = 0;

        // Read the Circles tile PNG intrinsic size so we can match the SVG pattern
        const circlesTile = new Image();
        let tileW = 100, tileH = 100;
        circlesTile.onload = function(){
          tileW = circlesTile.naturalWidth || tileW;
          tileH = circlesTile.naturalHeight || tileH;
          const cutleryPat = document.getElementById('cutleryPat');
          const cutleryImage = document.getElementById('cutleryImage');
          if(cutleryPat){
            cutleryPat.setAttribute('width', tileW);
            cutleryPat.setAttribute('height', tileH);
          }
          if(cutleryImage){
            cutleryImage.setAttribute('width', tileW);
            cutleryImage.setAttribute('height', tileH);
          }
        };
        circlesTile.src = 'Assets/Circles tile.png';

        const cutleryPat = document.getElementById('cutleryPat');
        const cutleryMaskCircle = document.getElementById('cutleryMaskCircle');

  // ============ DOWNLOAD LINK DETECTION ============
        // Map of utensil positions to OBJ files (positions are in the tile's 100x100 coordinate space)
        // Positions were derived from the source SVG viewBox (0..1412.09, 0..792.07) and normalized to 0..100.
        const utensilMap = [
          { name: 'S1', file: 'Assets/Models/S1_Model.obj', x: 36.86, y: 47.99, radius: 12 },
          { name: 'S2', file: 'Assets/Models/S2_Model.obj', x: 72.19, y: 15.95, radius: 12 },
          { name: 'S3', file: 'Assets/Models/S3_Model.obj', x: 60.07, y: 72.87, radius: 12 },
          { name: 'F1', file: 'Assets/Models/F1_Model.obj', x: 93.12, y: 57.09, radius: 14 },
          { name: 'F2', file: 'Assets/Models/F2_Model.obj', x: 19.34, y: 76.19, radius: 14 },
          { name: 'F3', file: 'Assets/Models/F3_Model.obj', x: 88.94, y: 91.06, radius: 14 },
          { name: 'K1', file: 'Assets/Models/K1_Model.obj', x: 92.52, y: 45.86, radius: 12 },
          { name: 'K2', file: 'Assets/Models/K2_Model.obj', x: 29.95, y: 28.83, radius: 12 },
          { name: 'K3', file: 'Assets/Models/K3_Model.obj', x: 74.07, y: 36.40, radius: 12 }
        ];

        // Attach click detection to the visible rect so we can map clicks to tile-local coordinates
        const clickableArea = document.getElementById('clickableArea');
        if (clickableArea) {
          clickableArea.addEventListener('click', (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Calculate position within the tile (accounting for pan offset)
            const tileX = ((clickX - posX) % tileW + tileW) % tileW;
            const tileY = ((clickY - posY) % tileH + tileH) % tileH;

            // Check if click is near any utensil
            for (const utensil of utensilMap) {
              const dx = tileX - utensil.x;
              const dy = tileY - utensil.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance <= utensil.radius) {
                // Trigger fetch + forced download via blob -> object URL
                (async () => {
                  // ensure a small on-page status element exists for debug messages
                  let statusEl = document.getElementById('downloadStatus');
                  if (!statusEl) {
                    statusEl = document.createElement('div');
                    statusEl.id = 'downloadStatus';
                    Object.assign(statusEl.style, {position: 'fixed', right: '16px', top: '16px', padding: '8px 12px', background: 'rgba(0,0,0,0.7)', color:'#fff', fontSize:'12px', borderRadius:'6px', zIndex:100000});
                    document.body.appendChild(statusEl);
                  }

                  try {
                    statusEl.textContent = `Fetching ${utensil.file}...`;
                    console.log(`Fetching ${utensil.file}...`);
                    const res = await fetch(utensil.file, { cache: 'no-store' });
                    statusEl.textContent = `HTTP ${res.status} ${res.statusText}`;
                    if (!res.ok) throw new Error(`Network response was not ok (${res.status})`);
                    const blob = await res.blob();
                    statusEl.textContent = `Preparing download...`;
                    const url = URL.createObjectURL(blob);
                    const filename = utensil.file.split('/').pop();
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    statusEl.textContent = `Download started: ${filename}`;
                    setTimeout(() => { URL.revokeObjectURL(url); statusEl.textContent = ''; }, 2000);
                    console.log(`Forced download started for ${utensil.name}: ${utensil.file}`);
                  } catch (err) {
                    console.error('Download failed', err);
                    statusEl.textContent = `Download failed: ${err.message}`;
                    // Fallback: open file in new tab so user can inspect network error
                    window.open(utensil.file, '_blank');
                  }
                })();
                return;
              }
            }

            console.log(`Click at tile position: (${Math.round(tileX)}, ${Math.round(tileY)})`);
          }, {passive: true});
        }

        function syncCutleryPat(){
          if(cutleryPat) cutleryPat.setAttribute('patternTransform', `translate(${posX} ${posY})`);
        }

        function updateCutleryMask(x, y, size){
          if(!cutleryMaskCircle) return;
          cutleryMaskCircle.setAttribute('cx', String(x));
          cutleryMaskCircle.setAttribute('cy', String(y));
          cutleryMaskCircle.setAttribute('r', String(size/2));
        }

        // Edge pan settings
        const edgeThreshold = 48; // px from edge to start panning
        const maxSpeed = 7.2; // px per frame at the edge

        // RAF loop: pan background only when pointer is near an edge
        function rafLoop(){
          if(pointer.inside && pointer.x !== null){
            const w = window.innerWidth, h = window.innerHeight;
            let vx = 0, vy = 0;

            if(pointer.x <= edgeThreshold) {
              // closer to left edge => move background left
              vx = maxSpeed * (1 - pointer.x / edgeThreshold);
            } else if(pointer.x >= w - edgeThreshold){
              vx = -maxSpeed * (1 - (w - pointer.x) / edgeThreshold);
            }

            if(pointer.y <= edgeThreshold){
              vy = maxSpeed * (1 - pointer.y / edgeThreshold);
            } else if(pointer.y >= h - edgeThreshold){
              vy = -maxSpeed * (1 - (h - pointer.y) / edgeThreshold);
            }

            if(vx !== 0 || vy !== 0){
              posX += vx;
              posY += vy;
              // apply background position (repeat makes it seamless)
              body.style.backgroundPosition = `${posX}px ${posY}px`;
              syncCutleryPat();
            }
          }

          requestAnimationFrame(rafLoop);
        }
        requestAnimationFrame(rafLoop);

        // Wheel / trackpad: resize the circular cursor
        // Use wheel delta to change size; prevent default to avoid accidental scrolling
        window.addEventListener('wheel', (e)=>{
          // prefer pinch/trackpad gestures; allow normal wheel too
          // invert deltaY so wheel-up increases size
          const delta = -e.deltaY;
          if(Math.abs(delta) < 0.5) return; // ignore tiny deltas
          e.preventDefault();
          // sensitivity scaling
          const change = delta * 0.4; // tune this factor if needed
          cursorSize = Math.max(minSize, Math.min(maxSize, Math.round(cursorSize + change)));
          cursor.style.width = cursorSize + 'px';
          cursor.style.height = cursorSize + 'px';
          // update mask radius at current pointer position (or center if none)
          updateCutleryMask(pointer.x || window.innerWidth/2, pointer.y || window.innerHeight/2, cursorSize);
        }, {passive:false});

        // Popup wiring: center button closes popup and fit text on popup rotor
        (function(){
          const popup = document.getElementById('pop-up');
          const popupBuy = document.getElementById('popupBuy');
          if(popupBuy && popup){
            popupBuy.addEventListener('click', (e)=>{ e.preventDefault(); popup.remove(); });
          }

          // Fit popup rotor text to its path (same method as index.html)
          const path = document.getElementById('popupCirclePath');
          const textPath = document.getElementById('popupCircleTextPath');
          const textEl = document.getElementById('popupCircleText');
          if(path && textPath && textEl){
            function fit(){
              const length = path.getTotalLength();
              textPath.setAttribute('textLength', length);
              textPath.setAttribute('lengthAdjust', 'spacingAndGlyphs');
              const fontSize = Math.max(12, Math.min(22, Math.round(length / 20)));
              textEl.style.fontSize = fontSize + 'px';
              // ensure centered alignment
              textPath.setAttribute('startOffset', '50%');
              textEl.setAttribute('text-anchor', 'middle');
            }
            fit();
            let tto; window.addEventListener('resize', ()=>{ clearTimeout(tto); tto = setTimeout(fit, 120); });
          }
        })();

        
      })();
    </script>
  </body>
</html>
